# BenzoApp Security Vulnerability Assessment

**Assessment Date**: 2025-02-07  
**Assessor**: Senior Cybersecurity Expert  
**Scope**: Full codebase review (backend + frontend)  
**Severity Scale**: Critical | High | Medium | Low | Informational

---

## Executive Summary

The BenzoApp codebase contains **7 security vulnerabilities** ranging from **HIGH** to **LOW** severity. The most critical issues involve:

- **Cross-Site Scripting (XSS)** via unsafe `innerHTML` usage
- **Server-Side Request Forgery (SSRF)** potential in geocoding service
- **Missing security headers** and rate limiting
- **CORS configuration** risks with credentials

Immediate remediation is recommended before production deployment.

---

## Vulnerability Details

### 1. Cross-Site Scripting (XSS) via innerHTML - **HIGH**

**Location**: [`src/static/js/app.ui.js`](src/static/js/app.ui.js:371)  
**Component**: `loadComponent()` function

```javascript
async loadComponent(url, elementId) {
  const response = await fetch(url);
  const data = await response.text();
  const element = document.getElementById(elementId);
  if (element) {
    element.innerHTML = data;  // âš ï¸ UNSAFE
  }
}
```

**Risk**: The function fetches HTML templates and injects them using `innerHTML` without sanitization. If an attacker can manipulate the template files or perform a MITM attack, they can inject arbitrary JavaScript.

**Attack Vector**:
- Compromise of static template files
- Network injection if HTTPS is not enforced
- Path traversal if URL parameter is ever user-controlled

**Impact**: Full XSS - session hijacking, credential theft, malware injection.

**Remediation**:
- Use a safe templating library (e.g., DOMPurify for sanitization)
- Prefer framework-based rendering (Alpine.js already used)
- Implement Content Security Policy (CSP)

---

### 2. Server-Side Request Forgery (SSRF) - **HIGH**

**Location**: [`src/services/geocoding.py`](src/services/geocoding.py:42-46)  
**Component**: `geocode_city()` function

```python
response = await http_client.get(
    settings.nominatim_api_url,
    params={"q": city, "format": "json", "limit": 1},
    headers={"User-Agent": settings.user_agent},
)
```

**Risk**: The `nominatim_api_url` is loaded from environment variables but could be manipulated if `.env` is compromised or if the application is deployed with user-provided configuration. An attacker could set this to an internal URL (e.g., `http://169.254.169.254/` for AWS metadata) to scan internal networks.

**Current Mitigation**: URL is from Settings with default hardcoded value.  
**Missing**: URL validation/whitelisting.

**Impact**:
- Internal network reconnaissance
- Access to cloud metadata endpoints (AWS/GCP/Azure)
- Port scanning of internal services

**Remediation**:
- Validate `nominatim_api_url` against a whitelist
- Disable redirects in httpx client (`follow_redirects=False`)
- Use a strict allowlist: `https://nominatim.openstreetmap.org/*`

---

### 3. Missing Rate Limiting - **HIGH**

**Location**: [`src/main.py`](src/main.py:125) `/search` endpoint  
**Component**: `search_gas_stations()` endpoint

**Issue**: No rate limiting implemented. The `/search` endpoint makes external API calls to Prezzi Carburante API and Nominatim. Unauthenticated users can flood these endpoints.

**Impact**:
- Denial of Service to external APIs
- Resource exhaustion (connection pool depletion)
- Increased costs if external APIs are rate-limited/paid

**Remediation**:
- Implement rate limiting middleware (e.g., `slowapi` or `starlette-limiter`)
- Example: 10 requests per minute per IP
- Consider API key for production

---

### 4. CORS Configuration with Credentials - **MEDIUM-HIGH**

**Location**: [`src/main.py`](src/main.py:89-95)  
**Component**: CORSMiddleware configuration

```python
app.add_middleware(
    CORSMiddleware,
    allow_origins=get_settings().cors_allowed_origins,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)
```

**Risk**: 
- `allow_credentials=True` with `allow_origins` from environment variable
- If `CORS_ALLOWED_ORIGINS` is misconfigured (e.g., `*` or includes untrusted domains), cookies/credentials can be exposed
- `allow_headers=["*"]` and `allow_methods=["*"]` are overly permissive

**Current State**: Default is `http://127.0.0.1:8000` (safe for dev) but could be changed in production.

**Impact**: Credential theft, session hijacking if misconfigured.

**Remediation**:
- Validate `cors_allowed_origins` are explicit URLs (no wildcards)
- Remove `allow_credentials=True` unless absolutely necessary
- Specify exact methods and headers needed
- Add CORS preflight caching: `max_age=600`

---

### 5. Missing Security Headers - **MEDIUM**

**Location**: [`src/main.py`](src/main.py) - All HTTP responses

**Missing Headers**:
- `Content-Security-Policy` (CSP) - prevents XSS, data injection
- `X-Content-Type-Options: nosniff` - prevents MIME sniffing
- `X-Frame-Options: DENY` - prevents clickjacking
- `Strict-Transport-Security` (HSTS) - forces HTTPS
- `Referrer-Policy` - controls referrer leakage

**Impact**: Increased attack surface for XSS, clickjacking, MIME confusion.

**Remediation**:
Add security headers middleware:

```python
from starlette.middleware.base import BaseHTTPMiddleware

class SecurityHeadersMiddleware(BaseHTTPMiddleware):
    async def dispatch(self, request, call_next):
        response = await call_next(request)
        response.headers["X-Content-Type-Options"] = "nosniff"
        response.headers["X-Frame-Options"] = "DENY"
        response.headers["Referrer-Policy"] = "strict-origin-when-cross-origin"
        # CSP should be tuned to your needs
        response.headers["Content-Security-Policy"] = "default-src 'self'; script-src 'self' 'unsafe-inline' https://unpkg.com; style-src 'self' 'unsafe-inline' https://fonts.googleapis.com; img-src 'self' data: https:; font-src 'self' https://fonts.gstatic.com"
        return response
```

---

### 6. Markdown Rendering with HTML - **MEDIUM**

**Location**: [`src/main.py`](src/main.py:233-236)  
**Component**: `render_docs()` endpoint

```python
rendered = py_markdown(md_text, extensions=["tables", "fenced_code", "attr_list"])
```

**Risk**: The `markdown` library with `attr_list` extension allows raw HTML in markdown. If documentation files are editable by users (or if file upload is ever supported), this becomes an XSS vector.

**Current Mitigation**: Files are from local `docs/` directory (trusted).

**Impact**: Low in current state, but escalates if docs become writable by untrusted users.

**Remediation**:
- Use `markdown` with `safe_mode=True` or an HTML sanitizer
- Remove `attr_list` if not needed
- Consider using a locked-down renderer like `markdown-it` with sanitization

---

### 7. Geolocation API Open to All Users - **MEDIUM**

**Location**: [`src/static/js/app.map.js`](src/static/js/app.map.js:129-143)  
**Component**: `locateUser()` function

```javascript
locateUser() {
  navigator.geolocation.getCurrentPosition(
    (position) => {
      this.formData.city = "Current Location";
      this.submitForm();
    },
    (error) => {
      this.error = "Unable to retrieve your location";
    },
  );
}
```

**Risk**: No explicit user consent check beyond browser prompt. The app immediately submits the form after obtaining location, potentially without clear user understanding.

**Impact**: Privacy concern - location shared with external APIs without explicit context.

**Remediation**:
- Add UI confirmation before submitting
- Allow user to review/edit location before submission
- Provide clear privacy notice

---

### 8. Cache Poisoning in Geocoding - **LOW-MEDIUM**

**Location**: [`src/services/geocoding.py`](src/services/geocoding.py:72)  
**Component**: `geocoding_cache` (TTLCache)

```python
geocoding_cache[city] = result
```

**Risk**: Cache key is user-provided `city` string. No normalization (lowercasing, trimming). Attacker could poison cache with:
- `"Rome"` vs `"rome"` (different keys)
- `" Rome "` with whitespace
- Unicode homoglyphs

**Impact**: Cache misses (performance) or poisoning (incorrect results).

**Remediation**:
- Normalize keys: `city_key = city.strip().lower()`
- Validate city name format before caching

---

### 9. Client-Side Validation Only - **LOW**

**Location**: [`src/static/js/app.ui.js`](src/static/js/app.ui.js:451-466)  
**Component**: `submitForm()` radius and results parsing

```javascript
radius: Number.parseInt(this.formData.radius, window.CONFIG.PARSE_INT_RADIX),
results: Number.parseInt(this.formData.results, window.CONFIG.PARSE_INT_RADIX),
```

**Risk**: Client-side validation can be bypassed. Backend does validate (Pydantic), but defense-in-depth suggests also validating on client to prevent unnecessary requests.

**Impact**: Minor - backend validation is present.

**Remediation**:
- Add client-side validation before submit
- Show clear error messages

---

### 10. Dependency Security - **INFORMATIONAL**

**Location**: [`pyproject.toml`](pyproject.toml:8-27)  
**Dependencies**: Standard FastAPI stack

**Status**: Dependencies are modern and from PyPI. No known CVEs detected in this review, but:
- `markdown` library has had XSS vulnerabilities in past versions
- `httpx` and `tenacity` are well-maintained

**Recommendation**:
- Run `uv lock --update` regularly
- Use `safety` or `dependabot` for vulnerability scanning
- Pin versions in production (already using `uv.lock`)

---

## Risk Prioritization Matrix

| Vulnerability | Severity | Exploitability | Impact | Priority |
|---------------|----------|----------------|--------|----------|
| XSS via innerHTML | HIGH | Easy | High | **P0** |
| SSRF Potential | HIGH | Medium | High | **P0** |
| No Rate Limiting | HIGH | Easy | Medium | **P1** |
| CORS Misconfiguration | MEDIUM-HIGH | Medium | Medium | **P1** |
| Missing Security Headers | MEDIUM | Hard | Medium | **P2** |
| Markdown HTML Rendering | MEDIUM | Hard | Low-Medium | **P2** |
| Geolocation Privacy | MEDIUM | N/A | Low-Medium | **P3** |
| Cache Poisoning | LOW-MEDIUM | Medium | Low | **P3** |
| Client-Side Validation | LOW | Hard | Low | **P4** |

---

## Remediation Plan

### Immediate Actions (P0-P1 - Deploy within 1 week)

1. **Fix XSS**: Replace `innerHTML` with safe DOM methods or sanitize with DOMPurify
2. **Mitigate SSRF**: Add URL whitelist validation for external APIs, disable redirects
3. **Add Rate Limiting**: Implement per-IP rate limiting on `/search` endpoint
4. **Review CORS**: Validate `CORS_ALLOWED_ORIGINS` doesn't contain wildcards; consider removing credentials

### Short-Term (P2 - Deploy within 2 weeks)

5. **Add Security Headers Middleware**: Implement all recommended headers
6. **Sanitize Markdown**: Enable safe mode or use HTML sanitizer in docs rendering

### Medium-Term (P3-P4 - Deploy within 1 month)

7. **Geolocation UX**: Add confirmation dialog before location submission
8. **Cache Normalization**: Normalize city names before caching
9. **Client Validation**: Add input validation in frontend

---

## Testing Recommendations

- **Penetration Test**: Focus on XSS and SSRF vectors
- **Dependency Audit**: Run `safety check` or `pip-audit`
- **Static Analysis**: Use `bandit` for Python security scanning
- **CORS Testing**: Verify CORS headers with different origins
- **Rate Limiting Test**: Load test `/search` endpoint

---

## Conclusion

BenzoApp has a solid foundation with Pydantic validation, retry logic, and structured code. However, **security must be hardened** before production use, particularly around XSS and SSRF. The recommended fixes are straightforward and should be prioritized accordingly.

**Overall Security Rating**: ðŸŸ¡ **Medium Risk** (needs remediation)
